<!--
* eleVR Web Player: A web player for 360 video on the Oculus
* Copyright (C) 2014 Andrea Hawksley and Andrew Lutomirski
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-->
<!DOCTYPE html>
<html>
<head>
  <title>eleVR Web Player</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="icon" sizes="196x196" href="elelogo-square.png">

  <!-- Fragment shader program -->
  <script id="shader-fs" type="x-shader/x-fragment">
  varying mediump vec3 vDirection;
  uniform mediump float eye;
  uniform mediump float projection;
  uniform mediump float time;


  uniform sampler2D uSampler;

  #define PI 3.1415926535897932384626433832795
const mediump float pi = 3.14159;
const mediump float pi2 = 2.0*pi;

const mediump float WIDTH = 1024.0;
const mediump float HEIGHT = WIDTH /2.0;

  mediump vec2 iMouse = vec2(WIDTH/2.,HEIGHT/2.);
  mediump float iGlobalTime = 10.0;
mediump float determinant(mediump mat2 m) {
    return m[0][0]*m[1][1]-m[0][1]*m[1][0];
}

mediump mat2 inverse(mediump mat2 m) {
    return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / determinant(m);
}

//https://github.com/mkovacs/reim/blob/master/reim.glsl

mediump vec2 cConj(mediump vec2 c)
{
    return vec2(c.x, -c.y);
}
mediump float cReal(mediump vec2 c)
{
    return c.x;
}
mediump vec2 complex(mediump float r, mediump float i){
    return vec2(r,i);
}
mediump float cImag(mediump vec2 c)
{
    return c.y;
}
mediump vec2 cNeg(mediump vec2 c)
{
    return -c;
}
mediump vec2 cInv(mediump vec2 c)
{
    return cConj(c) / dot(c, c);
}
mediump vec2 cMul(mediump vec2 a, mediump vec2 b)
{
    return vec2(a.x*b.x - a.y*b.y,
                a.x*b.y + a.y*b.x);
}
mediump vec2 cDiv(mediump vec2 a, mediump vec2 b)
{
    return cMul(a, cInv(b));
}

mediump vec2 cCis(mediump float r)
{
  return vec2( cos(r), sin(r) );
}

mediump float cArg(mediump vec2 c)
{
  return atan(c.y, c.x);
}
mediump float cAbs(mediump vec2 c)
{
  return length(c);
}
mediump vec2 cCish(mediump float r)
{
  mediump vec2 e = vec2( exp(r), exp(-r) );
  return vec2(e.x + e.y, e.x - e.y);
}
mediump vec2 cExp(mediump vec2 c)
{
  return exp(c.x) * cCis(c.y);
}

mediump vec2 cLog(mediump vec2 c)
{
  return vec2( log( cAbs(c) ), cArg(c) );
}
struct CP1_coord {
    mediump vec2 z1;
    mediump vec2 z2;
};
struct CP1_mat {
    mediump mat2 real;
    mediump mat2 imag;
};

CP1_mat sub(CP1_mat a, CP1_mat b){
    return CP1_mat(a.real-b.real, a.imag-b.imag);
}

CP1_mat make_CP1_mat(mediump vec2 p,mediump vec2 q,mediump vec2 r,mediump vec2 s) {
    return CP1_mat(mat2(p[0],q[0],
                        r[0],s[0]),
                   mat2(p[1],q[1],
                        r[1],s[1]));
}
void get_CP(in CP1_mat M, out mediump vec2 a, out mediump vec2 b,out mediump vec2 c,out mediump vec2 d){
    a = vec2(M.real[0][0], M.imag[0][0]);
    b = vec2(M.real[0][1], M.imag[0][1]);
    c = vec2(M.real[1][0], M.imag[1][0]);
    d = vec2(M.real[1][1], M.imag[1][1]);
}

CP1_mat matrix_mult(CP1_mat A, CP1_mat B){
    mediump vec2 a,b,c,d,e,f,g,h;
    get_CP(A,a,b,c,d);
    get_CP(B,e,f,g,h);
    
    return make_CP1_mat(
        cMul(a,e) + cMul(b,g), cMul(a,f) + cMul(b,h),
        cMul(c,e) + cMul(d,g), cMul(c,f) + cMul(d,h)
    );
}


CP1_mat matrix_mult(CP1_mat a, mediump vec2 b){
    mediump vec2 a_0_0,a_0_1, a_1_1, a_1_0;
    get_CP(a,a_0_0,a_0_1,a_1_0,a_1_1);

    return make_CP1_mat(cMul(a_0_0,b), cMul(a_1_0,b),
                        cMul(a_0_1,b), cMul(a_1_1,b));
}

void matrix_mult(CP1_mat A, mediump vec2 b1, mediump vec2 b2, out mediump vec2 out1, out mediump vec2 out2){
    mediump vec2 a,b,c,d;
    get_CP(A,a,b,c,d);

    out1 = cMul(a,b1) + cMul(b,b2);
    out2 = cMul(c,b1) + cMul(d,b2);
}

CP1_coord matrix_mult(CP1_mat A, CP1_coord b){
    mediump vec2 z1,z2;
    matrix_mult(A, b.z1, b.z2, z1, z2);
    return CP1_coord(z1,z2);
}

CP1_mat matrix2_inv(CP1_mat a){
    mediump vec2 a_0_0,a_0_1, a_1_1, a_1_0;
    get_CP(a,a_0_0,a_0_1,a_1_0,a_1_1);

    mediump vec2 det = cDiv(vec2(1.0,0),
                    cMul(a_0_0,a_1_1) - cMul(a_1_0,a_0_1));

    CP1_mat mat = make_CP1_mat( a_1_1, -a_1_0,
                               -a_0_1,  a_0_0);
    return matrix_mult(mat,det);
}



mediump vec4 draw2by2(mediump mat2 mat, mediump vec2 point, mediump vec4 color){
    mediump float scale = 50.0;
    point.y = 2. * scale - point.y;

    if (point.x < 0. || point.y < 0.){
        return vec4(0.,0.,0.,0.);
    }
    mediump float val = 0.0;
    if (point.x < scale && point.y < scale){
        val = mat[0][0];
    } else if (point.x < scale*2. && point.y < scale){
        val = mat[0][1];
    }else if (point.y < scale*2. && point.x < scale){
        val = mat[1][0];
    } else if (point.y < scale*2. && point.x < scale*2.){
        val = mat[1][1];
    }
    if (val < 0.){
        color = color *-float(mod(point.x,2.0)>1.)-float(mod(point.y,2.0)>1.);
    }
    if (val > 1. && (mod(point.x,2.0)>1.)){
        color.y = val-1.;
    }
    return val * color;
}


mediump vec4 draw(CP1_mat mat, mediump vec2 point){
    mediump vec4 ret = draw2by2(mat.real,point,vec4(1.,0.,0.,1.));
    ret += draw2by2(mat.imag,point-vec2(40.,0.),vec4(0.,1.,0.,1.));
    return ret;
}
mediump vec4 draw(CP1_coord pt, mediump vec2 point){
    mediump vec4 ret = draw2by2(mat2(vec2(pt.z1.x,0.), vec2(pt.z2.x,0.)),point,vec4(1.,0.,0.,1.));
    ret += draw2by2(mat2(vec2(pt.z1.y,0.), vec2(pt.z2.y,0.)),point-vec2(50.,0.),vec4(0.,1.,0.,1.));
    return ret;
}

mediump vec2 angles_from_pixel_coords(in mediump vec2 point, in mediump float x_size){
    //map from pixel coords to (0, 2*pi) x (-pi/2, pi/2) rectangle"""
    mediump float y_size = x_size/2.0;  //assume equirectangular format
    return vec2(point[0] * 2.0*pi/x_size, 
                point[1] * pi/(y_size-1.0) - 0.5*pi);
}


mediump vec2 pixel_coords_from_angles(in mediump vec2 point, in mediump float x_size){
    //map from (0, 2*pi) x (-pi/2, pi/2) rectangle to pixel coords"""
    mediump float y_size = x_size/2.0;  //assume equirectangular format
    return vec2(point[0] * float(x_size)/(2.0*pi), (point[1] + 0.5*pi)* float(y_size-1.0)/pi);
}


mediump vec2 angles_from_sphere(in mediump vec3 point){
    //map from sphere in R^3 to (0, 2*pi) x (-pi/2, pi/2) rectangle (i.e. perform equirectangular projection)"""
    mediump float longitude = atan(point.y,point.x);
    if (longitude < 0.0){
        longitude = longitude + pi2;
    }
    mediump float r = sqrt(point.x*point.x+point.y*point.y);
    mediump float latitude = atan(point.z,r);
    return vec2(longitude, latitude);
}

mediump vec3 sphere_from_angles(in mediump vec2 point){
    //map from (0, 2*pi) x (-pi/2, pi/2) rectangle to sphere in R^3 (i.e. perform inverse of equirectangular projection)"""
    mediump float horiz_radius = cos(point.y);
    
    return vec3(horiz_radius*cos(point.x), 
                horiz_radius*sin(point.x),
                sin(point.y));
}

CP1_coord CP1_from_sphere(in mediump vec3 point) {
    //map from sphere in R^3 to CP^1"""
    if (point.z < 0.0){
        return CP1_coord(vec2(point.x,point.y), vec2(1.0-point.z,0));
    }     else{
        return CP1_coord(vec2(1.0+point.z,0.0), vec2(point.x,-point.y));
    }
}


mediump vec3 sphere_from_CP1(in CP1_coord point){
    //map from CP^1 to sphere in R^3"""
    if (length(point.z2) > length(point.z1)){
        mediump vec2 z = cDiv(point.z1,point.z2);
        mediump vec2 tmp = vec2(z.x, z.y); // x is real, y imag
        mediump float denom = 1.0 + z.x*z.x + z.y*z.y;
        return vec3(2.0*z.x/denom, 2.0*z.y/denom, (denom - 2.0)/denom);
    } else {
        mediump vec2 z = cConj(cDiv(point.z2,point.z1));
        mediump float denom = 1.0 + z.x*z.x + z.y*z.y;
        return vec3(2.0*z.x/denom, 2.0*z.y/denom, (2.0 - denom)/denom);
    }
}

mediump vec2 clamp(in mediump vec2 point, in mediump float x_size){
    //clamp to size of input, including wrapping around in the x direction""" 
    mediump float y_size = x_size/2.0;      // assume equirectangular format
    mediump vec2 ret = vec2(mod(point.x,x_size), point.y);
    if (point.y < 0.0){
        ret.y = 0.0;
    } else if ( point.y > y_size - 1.0) {
        ret.y = y_size - 1.0;
    } 
    return ret;
}
mediump vec3 sphere_from_pixel_coords(in mediump vec2 point, in mediump float x_size){
    //map from pixel coords to sphere in R^3"""
    return sphere_from_angles(angles_from_pixel_coords(point, x_size));
}



CP1_mat inf_zero_one_to_triple(CP1_coord p,CP1_coord q,CP1_coord r){
    //"""returns SL(2,C) matrix that sends the three points infinity, zero, one to given input points p,q,r"""
    //### infinity = [1,0], zero = [0,1], one = [1,1] in CP^1
    CP1_mat M = make_CP1_mat(p.z1,q.z1,
                             p.z2,q.z2);
    CP1_mat Minv = matrix2_inv(M);
    mediump vec2 mu, lam;
    matrix_mult(Minv,r.z1,r.z2,mu,lam);
    return make_CP1_mat(cMul(mu,p.z1), cMul(lam,q.z1),
                        cMul(mu,p.z2), cMul(lam,q.z2));
}
CP1_mat two_triples_to_SL(CP1_coord a1,CP1_coord b1,CP1_coord c1,CP1_coord a2,CP1_coord b2,CP1_coord c2){
    //"""returns SL(2,C) matrix that sends the three CP^1 points a1,b1,c1 to a2,b2,c2"""
    return matrix_mult( inf_zero_one_to_triple(a2,b2,c2), matrix2_inv(inf_zero_one_to_triple(a1,b1,c1) ) ) ;
}


CP1_mat three_points_to_three_points_pixel_coords(mediump vec2 p1, mediump vec2 q1, mediump vec2 r1, mediump vec2 p2, mediump vec2 q2, mediump vec2 r2, mediump float x_size){
    //  """returns SL(2,C) matrix that sends the three pixel coordinate points a1,b1,c1 to a2,b2,c2"""
    CP1_coord p1_ = CP1_from_sphere(sphere_from_pixel_coords(p1,x_size));
    CP1_coord q1_ = CP1_from_sphere(sphere_from_pixel_coords(q1,x_size));
    CP1_coord r1_ = CP1_from_sphere(sphere_from_pixel_coords(r1,x_size));
    CP1_coord p2_ = CP1_from_sphere(sphere_from_pixel_coords(p2,x_size));
    CP1_coord q2_ = CP1_from_sphere(sphere_from_pixel_coords(q2,x_size));
    CP1_coord r2_ = CP1_from_sphere(sphere_from_pixel_coords(r2,x_size));

    return two_triples_to_SL(p1_,q1_,r1_,p2_,q2_,r2_);
}

mediump vec3 get_vector_perp_to_p_and_q(mediump vec3 p, mediump vec3 q){
    //"""p and q are distinct points on sphere, return a unit vector perpendicular to both"""
    if (abs(dot(p,q) + 1.0) < 0.0001){ //### deal with the awkward special case when p and q are antipodal on the sphere
        if (abs(dot(p, vec3(1.0,0.0,0.0))) > 0.9999){ //#p is parallel to (1,0,0)
            return vec3(0.0,1.0,0.0);
        } else {
            return normalize(cross(p, vec3(1.0,0.0,0.0)));
        }
    } else {
        return normalize(cross(p, q));
    }
}

CP1_mat rotate_sphere_points_p_to_q(mediump vec3 p, mediump vec3 q){
    //"""p and q are points on the sphere, return SL(2,C) matrix rotating image of p to image of q on CP^1"""

    CP1_coord CP1p = CP1_from_sphere(p);
    CP1_coord CP1q = CP1_from_sphere(q);

    if (abs(dot(p,q) - 1.0) < 0.0001){
        return make_CP1_mat(vec2(1.0,0.0),vec2(0.0,0.0),
                            vec2(0.0,0.0),vec2(1.0,0.0));
    } else {
        mediump vec3 r = get_vector_perp_to_p_and_q(p, q);
        CP1_coord CP1r = CP1_from_sphere(r);
        CP1_coord CP1mr =  CP1_from_sphere(-r);
        return two_triples_to_SL(CP1p, CP1r, CP1mr, CP1q, CP1r, CP1mr) ;
    }
}

CP1_mat rotate_pixel_coords_p_to_q(mediump vec2 p_, mediump vec2 q_, mediump float x_size){
    //"""p and q are pixel coordinate points, return SL(2,C) matrix rotating image of p to image of q on CP^1"""
    mediump vec3 p = sphere_from_pixel_coords(p_, x_size);
    mediump vec3 q = sphere_from_pixel_coords(q_, x_size);
    return rotate_sphere_points_p_to_q(p,q);
}

CP1_mat rotate_around_axis_sphere_points_p_q(mediump vec3 p,mediump vec3 q, mediump float theta){
    //"""p and q are points on sphere, return SL(2,C) matrix rotating by angle theta around the axis from p to q"""
    CP1_coord CP1p = CP1_from_sphere(p);
    CP1_coord CP1q = CP1_from_sphere(q);
    //assert dot(p,q) < 0.9999, "axis points should not be in the same place!"
    mediump vec3 r = get_vector_perp_to_p_and_q(p, q);
    CP1_coord CP1r = CP1_from_sphere(r);
    CP1_mat M_standardise = two_triples_to_SL(CP1p, CP1q, CP1r,
                                              CP1_coord(vec2(0.0,0.0),vec2(1.0,0.0)),
                                              CP1_coord(vec2(1.0,0.0),vec2(0.0,0.0)),
                                              CP1_coord(vec2(1.0,0.0),vec2(1.0,0.0)));
    CP1_mat M_theta = make_CP1_mat(vec2(cos(theta),sin(theta)),vec2(0.0,0.0),
                                   vec2(0.0,0.0),vec2(1.0,0.0));// #rotate on axis through 0, infty by theta
    return matrix_mult( matrix_mult(matrix2_inv(M_standardise), M_theta), M_standardise );
}

CP1_mat rotate_around_axis_pixel_coords_p_q(mediump vec2 p_,mediump vec2 q_, mediump float theta, mediump float x_size){
    //"""p and q are pixel coordinate points, return SL(2,C) matrix rotating by angle theta around the axis from p to q"""
    

    mediump vec3 p = sphere_from_pixel_coords(p_, x_size);
    mediump vec3 q = sphere_from_pixel_coords(q_, x_size);
    return rotate_around_axis_sphere_points_p_q(p,q,theta);
}
CP1_mat rotate_around_axis_pixel_coord_p(mediump vec2 p_,mediump float theta, mediump float x_size){
    //"""p is a pixel coordinate point, return SL(2,C) matrix rotating by angle theta around the axis from p to its antipode"""
    mediump vec3 p = sphere_from_pixel_coords(p_, x_size);
    mediump vec3 minus_p = -p;
    return rotate_around_axis_sphere_points_p_q(p,minus_p,theta);
}

CP1_mat zoom_in_on_pixel_coords(mediump vec2 p, mediump float zoom_factor, mediump float x_size){
    //"""p is pixel coordinate point, return SL(2,C) matrix zooming in on p by a factor of scale"""
    //# Note that the zoom factor is only accurate at the point p itself. As we move away from p, we zoom less and less.
    //# We zoom with the inverse zoom_factor towards/away from the antipodal point to p.
    CP1_mat M_rot = rotate_pixel_coords_p_to_q( p, vec2(0.0,0.0), x_size);
    CP1_mat M_scl = make_CP1_mat(vec2(zoom_factor,0.0),vec2(0.0,0.0),
                                 vec2(0.0,0.0),    vec2(1.0,0.0)); //### zoom in on zero in CP^1
    return matrix_mult( matrix_mult(matrix2_inv(M_rot), M_scl), M_rot );
}

CP1_mat zoom_along_axis_sphere_points_p_q(mediump vec3 p, mediump vec3 q, mediump float zoom_factor){
    //"""p and q are points on sphere, return SL(2,C) matrix zooming along axis from p to q"""
    CP1_coord CP1p = CP1_from_sphere(p);
    CP1_coord CP1q = CP1_from_sphere(q);
    //assert dot(p,q) < 0.9999   #points should not be in the same place
    mediump vec3 r = get_vector_perp_to_p_and_q(p, q);
    CP1_coord CP1r = CP1_from_sphere(r);
    CP1_mat M_standardise = two_triples_to_SL(CP1p, CP1q, CP1r,
                                              CP1_coord(vec2(0.0,0.0),vec2(1.0,0.0)),
                                              CP1_coord(vec2(1.0,0.0),vec2(0.0,0.0)),
                                              CP1_coord(vec2(1.0,0.0),vec2(1.0,0.0)));
    CP1_mat M_theta = make_CP1_mat(vec2(zoom_factor,0.0),vec2(0.0,0.0),
                                   vec2(0.0,0.0),    vec2(1.0,0.0)); 
    return matrix_mult( matrix_mult(matrix2_inv(M_standardise), M_theta), M_standardise );
}
CP1_mat zoom_along_axis_pixel_coords_p_q(mediump vec2 p_, mediump vec2 q_, mediump float zoom_factor, mediump float x_size){
    //"""p and q are pixel coordinate points, return SL(2,C) matrix zooming along axis from p to q by zoom_factor"""
    //# This function does the same thing as zoom_in_on_pixel_coords, but with the 
    //# two given points instead of a single point and its antipodal point
    mediump vec3 p = sphere_from_pixel_coords(p_, x_size);
    mediump vec3 q = sphere_from_pixel_coords(q_, x_size);
    return zoom_along_axis_sphere_points_p_q(p,q,zoom_factor);
}

CP1_mat translate_along_axis_pixel_coords(mediump vec2 p, mediump vec2 q, mediump vec2 r1, mediump vec2 r2, mediump float x_size){
    //"""Return SL(2,C) matrix translating/rotating on the axis from p to q, taking r1 to r2"""
    return three_points_to_three_points_pixel_coords(p,q,r1,p,q,r2, x_size);
}

mediump vec2 apply_SL2C_elt_to_pt(CP1_mat M, mediump vec2 pt_){
    CP1_mat Minv = matrix2_inv(M);
    mediump vec2 pt = angles_from_pixel_coords(pt_, WIDTH);
    mediump vec3 pt2 = sphere_from_angles(pt);
    CP1_coord pt3 = CP1_from_sphere(pt2);
    mediump vec2 outa, outb;
    matrix_mult(Minv, pt3.z1,pt3.z2,outa,outb);
    CP1_coord pt4 = CP1_coord(outa,outb);
    mediump vec3 pt5 = sphere_from_CP1(pt4);
    mediump vec2 pt6 = angles_from_sphere(pt5);
    return pixel_coords_from_angles(pt6, WIDTH);
}
mediump vec2 droste_effect(mediump vec2 pt_,mediump vec2 zoom_center_pixel_coords, mediump float zoom_factor, mediump float zoom_cutoff,
                   bool twist,mediump float zoom_loop_value,mediump float out_x_size){
    CP1_mat M_rot = rotate_pixel_coords_p_to_q(zoom_center_pixel_coords, vec2(0.,0.), out_x_size);
  CP1_mat M_rot_inv = matrix2_inv(M_rot);
    
    mediump vec2 droste_factor = cDiv(cLog(complex(zoom_factor,0.)) + vec2(0., 2.*pi) , vec2(0., 2.*pi));
    
    mediump vec2 pt = angles_from_pixel_coords(pt_, out_x_size);
    mediump vec3 pt2 = sphere_from_angles(pt);
    CP1_coord pt3 = CP1_from_sphere(pt2);
    pt3 = matrix_mult(M_rot, pt3);
    
    pt = cDiv(pt3.z1,pt3.z2);
    pt = cLog(pt);
    if (twist){//:  # otherwise straight zoom
        pt = cMul(droste_factor,pt);
    }
    pt = complex(
        cReal(pt) + log(zoom_factor) * zoom_loop_value,
        cImag(pt)
    ); 
    pt = complex(
        mod(cReal(pt) + zoom_cutoff, log(zoom_factor)) - zoom_cutoff,
        cImag(pt)
    );
    pt = cExp(pt);
    pt3 = CP1_coord(
          pt,
          vec2(1.,0.)
        );// #back to projective coordinates
    pt3 = matrix_mult(M_rot_inv, pt3);
    pt2 = sphere_from_CP1(pt3);
    pt = angles_from_sphere(pt2);

    return pixel_coords_from_angles(pt, out_x_size);;
}
  mediump vec2 directionToPx(mediump vec3 direction, mediump float eye, mediump float projection) {
    /*
    * Input: a direction.  +x = right, +y = up, +z = backward.
    *        an eye. left = 0, right = 1.
    *        a projection. see ProjectionEnum in JS file for enum
    * Output: a color from the video
    *
    * Bug alert: the control flow here may screw up texture filtering.
    */

    mediump float theta = atan(direction.x, -1.0 * direction.z);
    mediump float phi = atan(direction.y, length(direction.xz));

    /*
    * The Nexus 7 and the Moto X (and possibly many others) have
    * a buggy atan2 implementation that screws up when the numerator
    * (the first argument) is too close to zero.  (The 1e-4 is carefully
    * chosen: 1e-5 doesn't fix the problem.
    */
    if (abs(direction.x) < 1e-4 * abs(direction.z))
    theta = 0.5*PI * (1.0 - sign(-1.0 * direction.z));
    if (abs(direction.y) < 1e-4 * length(direction.xz))
    phi = 0.0;

    // Uncomment to debug the transformations.
    // return vec4(theta / (2. * PI) + 0.5, phi / (2. * PI) + 0.5, 0., 0.);

    if (projection == 0.) {
      // Projection == 0: equirectangular projection
      return vec2(mod(theta / (2.0*PI), 1.0), phi / PI + 0.5);
    } else {
      // Projection == 1: equirectangular top/bottom 3D projection
      eye = 1. - eye;
      return vec2(mod(theta / (2.0*PI), 1.0), ((phi / PI + 0.5) + eye)/ 2.);
    }
  }

  mediump vec4 pxToColor(mediump vec2 px){
    return texture2D(uSampler, px/vec2(WIDTH,HEIGHT));
  }
  mediump vec2 demo1(mediump vec2 fragCoord){
      mediump vec2 center = vec2(WIDTH/2.,HEIGHT/2.);
    CP1_mat transform = zoom_in_on_pixel_coords(center,4.,WIDTH);
    mediump vec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);
    return outpt;
  }

mediump vec2 demo2(mediump vec2 fragCoord){
    mediump vec2 center = iMouse.xy;//vec2(220.,150.);
    CP1_mat transform = zoom_in_on_pixel_coords(iMouse.xy,3.,WIDTH);
  mediump vec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);
  return outpt;
}
mediump vec2 demo3(mediump vec2 fragCoord){
    mediump vec2 center1 = vec2(iMouse.xy);
    mediump vec2 center2 = vec2(iMouse.x + 100.,iMouse.y);
    /*if (distance(fragCoord,center1) < 5. || distance(fragCoord,center2) < 5.){
        return vec4(1.0,1.0,0.0,1.0);
    }*/
    CP1_mat transform = rotate_around_axis_pixel_coords_p_q(center1,center2,iGlobalTime/2.0,WIDTH);
  mediump vec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);
  return outpt;
}

mediump vec2 demo4(mediump vec2 fragCoord){
    mediump vec2 center = iMouse.xy;//vec2(220.,150.);
    /*if (distance(fragCoord,center) < 5.){
        return vec2(1.0,1.0,0.0,1.0);
    }*/
    CP1_mat transform = rotate_pixel_coords_p_to_q(vec2(WIDTH/2.,HEIGHT/2.), center,WIDTH);
    mediump vec2 outpt = apply_SL2C_elt_to_pt(transform,fragCoord.xy);
    return outpt;
}
mediump vec2 demo5(mediump vec2 fragCoord){
    mediump vec2 center = vec2(0.,0.);//vec2(iMouse.x,HEIGHT/2.);
    return droste_effect(
        fragCoord,center, 7.*iMouse.y/HEIGHT + 1.3,1., false, 1.0, WIDTH);

}
    mediump vec4 testpattern(mediump vec2 fragCoord){
      mediump vec2 sphere = angles_from_sphere(sphere_from_angles(angles_from_pixel_coords(
          pixel_coords_from_angles(
              angles_from_sphere(
                  sphere_from_CP1(
                      CP1_from_sphere(
                          sphere_from_pixel_coords(fragCoord.xy,WIDTH)))),WIDTH),WIDTH)));
      return vec4(sphere.x/(2.*pi),(sphere.y+pi/2.)/pi,0.0,1.0);
  }
  void main(void) {
    gl_FragColor = pxToColor(demo5(directionToPx(vDirection, eye, projection)*vec2(WIDTH,HEIGHT)));
    // if (gl_FragCoord.x > WIDTH || gl_FragCoord.y>HEIGHT){
    //     gl_FragColor = vec4(0.,0.,0.,0.);
    // }
  }
</script>

<!-- Vertex shader program -->
<script id="shader-vs" type="x-shader/x-vertex">
  attribute mediump vec2 aVertexPosition;

  uniform mediump mat4 proj_inv;

  varying mediump vec3 vDirection;

  void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0, 1.0);
    mediump vec4 projective_direction = proj_inv * gl_Position;
    vDirection = projective_direction.xyz / projective_direction.w;
  }
</script>

<link rel="stylesheet" href="css/font-awesome.css">
<link rel="stylesheet" href="css/elevr-player.css">
<script src="lib/gl-matrix.js" type="text/javascript"></script>
<script src="lib/util.js" type="text/javascript"></script>
<script src="js/controls.js" type="text/javascript"></script>
<script src="js/player-webgl.js" type="text/javascript"></script>
<script src="js/webvr.js" type="text/javascript"></script>
<script src="js/phonevr.js" type="text/javascript"></script>
<script src="js/elevr-player.js" type="text/javascript"></script>
</head>

<body>
  <div id="video-container">
    <!-- Loading Message -->
    <div id="left-load" class="left">
      <div id="title-l" class="title">Loading Video...</div>
      <div id="message-l" class="message hidden">Try WASD + Q/E</div>
    </div>
    <div id="right-load" class="right">
      <div id="title-r" class="title">Loading Video...</div>
      <div id="message-r" class="message hidden">Try WASD + Q/E</div>
    </div>
    <div id="left-play" class="left hidden">
      <a id="play-l" class="large-play fa fa-play fa-5x"></a>
    </div>
    <div id="right-play" class="right hidden">
      <a id="play-r" class="large-play fa fa-play fa-5x"></a>
    </div>

    <canvas id="glcanvas">
      Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
    </canvas>
    <video class="hidden" preload="auto" id="video" loop="true" webkit-playsinline crossOrigin="anonymous">
      <source src="therelaxatron2.mp4" type="video/mp4">
      <source src="therelaxatron.webm" type="video/webm">
    </video>
        <!-- Video Controls -->
        <div id="video-controls" class="hidden">
          <a id="play-pause" class="fa fa-play icon" title="Play"></a>


          <input type="range" id="seek-bar" value="0">

          <a id="loop" class="fa fa-chain-broken icon" title="Stop Looping"></a>

          <a id="mute" class="fa fa-volume-up icon" title="Mute"></a>

          <a id="recenter" class="fa fa-dot-circle-o icon" title="Recenter"></a>

          <a id="select-local-file" class="fa fa-folder-open icon rfloat" title="Select File"></a>

          <select id="projection-select" class="rfloat">
            <option value=0>Equirectangular</option>
            <option value=1>Equirectangular 3D</option>
          </select>

          <select id="video-select" class="rfloat">
            <option value="0therelaxatron2.mp4">The Relaxatron (mp4)</option>
            <option value="0therelaxatron.webm">The Relaxatron (webm)</option>
            <option value="1Vidcon5.mp4">Vidcon (mp4)</option>
            <option value="1Vidcon.webm">Vidcon (webm)</option>
          </select>

          <a id="full-screen" class="fa fa-expand icon rfloat" title="Full Screen"></a>
        </div>

        <script>runEleVRPlayer();</script>
      </div>

    </body></html>
